<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animated Gradient Shader</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        
        canvas {
            display: block;
        }
        
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 12px;
        }
        
        .control-group {
            margin-bottom: 10px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
        }
        
        input[type="range"] {
            width: 200px;
        }
        
        .title {
            position: absolute;
            top: 20px;
            right: 20px;
            color: rgba(255,255,255,0.7);
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="title">Visual Development</div>
    
    <div class="controls">
        <div class="control-group">
            <label>Speed: <span id="speedValue">1.0</span></label>
            <input type="range" id="speed" min="0" max="3" step="0.1" value="1.0">
        </div>
        
        <div class="control-group">
            <label>Waves: <span id="intensityValue">1.0</span></label>
            <input type="range" id="intensity" min="0" max="2" step="0.1" value="1.0">
        </div>
        
        <div class="control-group">
            <label>Colors: <span id="colorValue">0.5</span></label>
            <input type="range" id="colorMix" min="0" max="1" step="0.05" value="0.5">
        </div>
        
        <div class="control-group">
            <label>Height: <span id="heightValue">0.7</span></label>
            <input type="range" id="gradientHeight" min="0.3" max="1.0" step="0.05" value="0.7">
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Shader uniforms
        const uniforms = {
            u_time: { value: 0.0 },
            u_resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
            u_speed: { value: 1.0 },
            u_intensity: { value: 1.0 },
            u_colorMix: { value: 0.5 },
            u_gradientHeight: { value: 0.7 }
        };

        // Vertex shader
        const vertexShader = `
            void main() {
                gl_Position = vec4(position, 1.0);
            }
        `;

        // Fragment shader
        const fragmentShader = `
            uniform float u_time;
            uniform vec2 u_resolution;
            uniform float u_speed;
            uniform float u_intensity;
            uniform float u_colorMix;
            uniform float u_gradientHeight;

            float noise(vec2 p) {
                return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
            }

            float smoothNoise(vec2 p) {
                vec2 i = floor(p);
                vec2 f = fract(p);
                f = f * f * (3.0 - 2.0 * f);
                return mix(mix(noise(i), noise(i + vec2(1.0, 0.0)), f.x), 
                          mix(noise(i + vec2(0.0, 1.0)), noise(i + vec2(1.0, 1.0)), f.x), f.y);
            }

            float fractalNoise(vec2 p) {
                float value = 0.0;
                float amplitude = 0.5;
                for(int i = 0; i < 4; i++) {
                    value += amplitude * smoothNoise(p);
                    amplitude *= 0.5;
                    p *= 2.0;
                }
                return value;
            }

            void main() {
                vec2 uv = gl_FragCoord.xy / u_resolution.xy;
                float time = u_time * u_speed;
                
                // Create animated waves
                float wave1 = sin(uv.x * 6.28 + time * 0.8) * 0.1;
                float wave2 = sin(uv.x * 12.56 + time * 1.2) * 0.05;
                float wave3 = sin(uv.y * 4.71 + time * 0.6) * 0.08;
                
                // Add noise for organic movement
                float noiseValue = fractalNoise(uv * 3.0 + time * 0.3) * 0.15;
                float displacement = (wave1 + wave2 + wave3 + noiseValue) * u_intensity;
                float gradient = (uv.y + displacement) / u_gradientHeight;
                
                // Color palette
                vec3 color1 = vec3(0.1, 0.2, 0.8);  // Blue
                vec3 color2 = vec3(0.4, 0.1, 0.9);  // Purple
                vec3 color3 = vec3(0.9, 0.3, 0.1);  // Orange
                vec3 color4 = vec3(1.0, 0.6, 0.8);  // Pink
                
                vec3 finalColor;
                if (gradient < 0.33) {
                    finalColor = mix(color1, color2, gradient * 3.0);
                } else if (gradient < 0.66) {
                    finalColor = mix(color2, color3, (gradient - 0.33) * 3.0);
                } else {
                    finalColor = mix(color3, color4, (gradient - 0.66) * 3.0);
                }
                
                // Alternative palette mixing
                vec3 altColor1 = vec3(0.2, 0.1, 0.6);
                vec3 altColor2 = vec3(0.8, 0.2, 0.4);
                vec3 altColor3 = vec3(1.0, 0.5, 0.2);
                
                vec3 altFinalColor = gradient < 0.5 ? 
                    mix(altColor1, altColor2, gradient * 2.0) :
                    mix(altColor2, altColor3, (gradient - 0.5) * 2.0);
                
                finalColor = mix(finalColor, altFinalColor, u_colorMix);
                
                // Edge fading
                float fadeY = smoothstep(0.95, 0.7, uv.y) * smoothstep(0.05, 0.3, uv.y);
                float fadeX = smoothstep(0.05, 0.1, uv.x) * smoothstep(0.95, 0.9, uv.x);
                float gradientFade = smoothstep(-0.2, 0.8, gradient);
                
                finalColor *= fadeY * fadeX * gradientFade;
                finalColor += noise(uv * 500.0 + time) * 0.03; // Grain
                
                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;

        // Create material and mesh
        const material = new THREE.ShaderMaterial({
            uniforms: uniforms,
            vertexShader: vertexShader,
            fragmentShader: fragmentShader
        });

        const plane = new THREE.PlaneGeometry(2, 2);
        const mesh = new THREE.Mesh(plane, material);
        scene.add(mesh);

        // Event listeners for controls
        document.getElementById('speed').addEventListener('input', (e) => {
            uniforms.u_speed.value = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = e.target.value;
        });

        document.getElementById('intensity').addEventListener('input', (e) => {
            uniforms.u_intensity.value = parseFloat(e.target.value);
            document.getElementById('intensityValue').textContent = e.target.value;
        });

        document.getElementById('colorMix').addEventListener('input', (e) => {
            uniforms.u_colorMix.value = parseFloat(e.target.value);
            document.getElementById('colorValue').textContent = e.target.value;
        });

        document.getElementById('gradientHeight').addEventListener('input', (e) => {
            uniforms.u_gradientHeight.value = parseFloat(e.target.value);
            document.getElementById('heightValue').textContent = e.target.value;
        });

        // Animation and resize handling
        function animate() {
            requestAnimationFrame(animate);
            uniforms.u_time.value += 0.016;
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            const w = window.innerWidth, h = window.innerHeight;
            renderer.setSize(w, h);
            uniforms.u_resolution.value.set(w, h);
        });

        animate();
    </script>
</body>
</html>