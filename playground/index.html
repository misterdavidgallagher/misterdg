<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Oasis Shader Experiments</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=DM+Mono:wght@400&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" rel="stylesheet">
    <style>
        /* Basic reset and body styling */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'DM Mono', monospace;
            background: #000;
            overflow: hidden; /* Prevent scrollbars */
            height: 100vh; /* Full viewport height */
            width: 100vw; /* Full viewport width */
        }

        /* Canvas styling for full screen background */
        canvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 0; /* Behind other UI elements */
            width: 100vw;
            height: 100vh;
        }

        /* Home icon styling */
        .home-icon {
            position: fixed;
            top: 55px;
            left: 65px;
            z-index: 10; /* Above canvas */
            color: rgba(255, 255, 255, 0.5); /* Fallback color at 50% opacity, will be updated by JS */
            font-size: 18px;
            text-decoration: none;
            cursor: pointer;
            transition: opacity 0.2s ease;
            user-select: none; /* Prevent text selection */
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .home-icon:hover {
            opacity: 1.0;
        }

        /* Navigation container styling */
        .navigation {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%); /* Center horizontally */
            z-index: 10;
            display: flex;
            align-items: center;
            gap: 22px;
            user-select: none;
        }

        /* Navigation arrow buttons styling */
        .nav-arrow {
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border-radius: 50%; /* Circular shape */
            transition: background-color 0.2s ease;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8); /* Fallback color, will be updated by JS */
        }

        .nav-arrow:hover {
            opacity: 1.0;
        }

        /* Ensure nav arrow Material Symbols display at 12px */
        .nav-arrow .material-symbols-outlined {
            font-variation-settings: 'opsz' 12;
            font-size: 12px;
        }

        /* Home icon should be 14px */
        .home-icon .material-symbols-outlined {
            font-variation-settings: 'opsz' 18;
            font-size: 18px;
        }


        .nav-arrow.prev {
            transform: rotate(180deg); /* Rotate for previous arrow */
        }

        /* Navigation center container */
        .nav-center {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        /* Navigation title styling */
        .nav-title {
            font-family: 'DM Mono', monospace;
            font-size: 12px;
            font-weight: 400;
            color: rgba(255, 255, 255, 0.8); /* Fallback color, will be updated by JS */
            white-space: nowrap;
            width: 120px; /* Fixed width to prevent movement */
            text-align: center;
            transition: opacity 0.3s ease;
        }

        /* Pagination dots styling */
        .pagination-dots {
            display: flex;
            gap: 6px;
            align-items: center;
            justify-content: center;
        }

        .pagination-dot {
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .pagination-dot.active {
            background-color: rgba(255, 255, 255, 0.8);
            transform: scale(1.2);
        }

        .pagination-dot:hover {
            background-color: var(--dot-hover-color, rgba(255, 255, 255, 0.6)); /* Uses CSS custom property set by JS */
        }

        .nav-title.fading {
            opacity: 0; /* For fade out effect */
        }

        /* Responsive adjustments for smaller screens */
        @media (max-width: 768px) {
            .home-icon {
                top: 55px;
                left: 65px;
                font-size: 14px;
                width: 44px;
                height: 44px;
            }
            
            .navigation {
                bottom: 80px;
            }
        }

        @media (max-width: 480px) {
            .home-icon {
                top: 55px;
                left: 65px;
                font-size: 12px;
                width: 40px;
                height: 40px;
            }
            
            .navigation {
                bottom: 60px;
                gap: 18px;
            }
            
            .nav-arrow {
                width: 40px;
                height: 40px;
            }
            
            .nav-title {
                font-size: 11px;
                width: 100px;
            }
            
            .pagination-dot {
                width: 3px;
                height: 3px;
            }
        }
    </style>
</head>
<body>
    <!-- Home icon link -->
    <a href="https://misterdg.com" class="home-icon">
        <span class="material-symbols-outlined">waving_hand</span>
    </a>

    <!-- Navigation controls -->
    <div class="navigation">
        <div class="nav-arrow prev" id="prevBtn">
            <span class="material-symbols-outlined">arrow_forward_ios</span>
        </div>
        <div class="nav-center">
            <div class="nav-title" id="navTitle">Slide Away</div>
            <div class="pagination-dots" id="paginationDots">
                <!-- Dots will be generated by JavaScript -->
            </div>
        </div>
        <div class="nav-arrow next" id="nextBtn">
            <span class="material-symbols-outlined">arrow_forward_ios</span>
        </div>
    </div>

    <!-- Three.js library import -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Global variables for Three.js and application state
        let scene, camera, renderer, material, uniforms;
        let experiments = []; // Stores shader configurations
        let currentExperimentIndex = 0;
        let isTransitioning = false; // Flag to prevent multiple transitions
        let animationId; // To store requestAnimationFrame ID

        // Touch/swipe handling variables
        let touchStartX = 0;
        let touchEndX = 0;
        let minSwipeDistance = 50; // Minimum distance for a swipe gesture

        // Default shader uniforms, used as a base for all experiments
        const defaultUniforms = {
            u_time: { value: 0.0 },
            u_resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
            u_speed: { value: 0.9 },
            u_intensity: { value: 0.4 },
            u_colorMix: { value: 0.5 },
            u_gradientHeight: { value: 0.5 },
            u_audioBass: { value: 0.5194081668441906 },
            u_audioMid: { value: 0.32311009685292774 },
            u_audioHigh: { value: 0.037421024639720926 },
            u_audioOverall: { value: 0.1696532084113514 },
            u_audioSensitivity: { value: 1.5 },
            u_bassResponse: { value: 0.9 },
            u_midResponse: { value: 0.3 },
            u_highResponse: { value: 0 },
            u_waveDirection: { value: 255 },
            u_waveType: { value: 5 },
            u_autoRotate: { value: 1.0 },
            u_rotationSpeed: { value: 1.0 },
            u_flowPattern: { value: 0.6 },
            u_color1: { value: new THREE.Vector3(0.824, 0.741, 0.522) },
            u_color2: { value: new THREE.Vector3(0.820, 0.808, 0.710) },
            u_color3: { value: new THREE.Vector3(0.118, 0.216, 0.255) },
            u_color4: { value: new THREE.Vector3(0.565, 0.596, 0.486) },
            u_color5: { value: new THREE.Vector3(0.227, 0.486, 0.498) }
        };

        // Vertex shader code (passes position directly)
        const vertexShader = `
            void main() {
                gl_Position = vec4(position, 1.0);
            }
        `;

        // Fragment shader code (generates visual effects)
        const fragmentShader = `
            uniform float u_time;
            uniform vec2 u_resolution;
            uniform float u_speed;
            uniform float u_intensity;
            uniform float u_colorMix;
            uniform float u_gradientHeight;
            uniform float u_audioBass;
            uniform float u_audioMid;
            uniform float u_audioHigh;
            uniform float u_audioOverall;
            uniform float u_audioSensitivity;
            uniform float u_bassResponse;
            uniform float u_midResponse;
            uniform float u_highResponse;
            uniform float u_waveDirection;
            uniform int u_waveType;
            uniform float u_autoRotate;
            uniform float u_rotationSpeed;
            uniform float u_flowPattern;
            uniform vec3 u_color1;
            uniform vec3 u_color2;
            uniform vec3 u_color3;
            uniform vec3 u_color4;
            uniform vec3 u_color5;

            // Simple pseudo-random noise function
            float noise(vec2 p) {
                return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
            }

            // Smooth noise function using interpolation
            float smoothNoise(vec2 p) {
                vec2 i = floor(p);
                vec2 f = fract(p);
                f = f * f * (3.0 - 2.0 * f); // Smoothstep interpolation
                return mix(mix(noise(i), noise(i + vec2(1.0, 0.0)), f.x), 
                          mix(noise(i + vec2(0.0, 1.0)), noise(i + vec2(1.0, 1.0)), f.x), f.y);
            }

            // Fractal Brownian Motion (FBM) for more complex noise
            float fractalNoise(vec2 p) {
                float value = 0.0;
                float amplitude = 0.5;
                for(int i = 0; i < 4; i++) { // 4 octaves
                    value += amplitude * smoothNoise(p);
                    amplitude *= 0.5;
                    p *= 2.0;
                }
                return value;
            }

            // Rotates UV coordinates around the center
            vec2 rotateUV(vec2 uv, float angle) {
                float s = sin(angle);
                float c = cos(angle);
                return vec2(uv.x * c - uv.y * s, uv.x * s + uv.y * c);
            }

            void main() {
                vec2 uv = gl_FragCoord.xy / u_resolution.xy; // Normalized UV coordinates (0 to 1)
                vec2 centeredUV = uv - 0.5; // Centered UV coordinates (-0.5 to 0.5)
                
                // Audio reactivity for speed and amplitude
                float audioSpeedBoost = u_audioHigh * u_highResponse * 2.0;
                float time = u_time * (u_speed + audioSpeedBoost);
                float audioWaveAmplitude = u_audioBass * u_bassResponse * 0.3;
                float audioColorShift = u_audioMid * u_midResponse * 2.0;
                
                float currentDirection = u_waveDirection;
                // Auto-rotation based on uniform
                if (u_autoRotate > 0.5) {
                    currentDirection += time * u_rotationSpeed * 30.0;
                }
                float directionRad = currentDirection * 3.14159 / 180.0; // Convert degrees to radians
                
                float wave1, wave2, wave3; // Variables for different wave components
                
                // Switch case for different wave patterns based on u_waveType
                if (u_waveType == 0) { // Horizontal waves
                    wave1 = sin(uv.x * 6.28 * u_flowPattern + time * 0.8) * (0.1 + audioWaveAmplitude);
                    wave2 = sin(uv.x * 12.56 * u_flowPattern + time * 1.2) * (0.05 + audioWaveAmplitude * 0.5);
                    wave3 = sin(uv.y * 4.71 + time * 0.6) * (0.08 + audioWaveAmplitude * 0.3);
                } else if (u_waveType == 1) { // Vertical waves
                    wave1 = sin(uv.y * 6.28 * u_flowPattern + time * 0.8) * (0.1 + audioWaveAmplitude);
                    wave2 = sin(uv.y * 12.56 * u_flowPattern + time * 1.2) * (0.05 + audioWaveAmplitude * 0.5);
                    wave3 = sin(uv.x * 4.71 + time * 0.6) * (0.08 + audioWaveAmplitude * 0.3);
                } else if (u_waveType == 2) { // Rotated waves
                    vec2 rotatedUV = rotateUV(centeredUV, directionRad) + 0.5;
                    wave1 = sin(rotatedUV.x * 6.28 * u_flowPattern + time * 0.8) * (0.1 + audioWaveAmplitude);
                    wave2 = sin(rotatedUV.x * 12.56 * u_flowPattern + time * 1.2) * (0.05 + audioWaveAmplitude * 0.5);
                    wave3 = sin(rotatedUV.y * 4.71 + time * 0.6) * (0.08 + audioWaveAmplitude * 0.3);
                } else if (u_waveType == 3) { // Radial waves
                    float dist = length(centeredUV);
                    wave1 = sin(dist * 12.56 * u_flowPattern + time * 0.8) * (0.1 + audioWaveAmplitude);
                    wave2 = sin(dist * 25.12 * u_flowPattern + time * 1.2) * (0.05 + audioWaveAmplitude * 0.5);
                    float directionBias = sin(atan(centeredUV.y, centeredUV.x) + directionRad + time * 0.3);
                    wave3 = directionBias * 0.05 + sin(dist * 18.84 + time * 0.6) * (0.08 + audioWaveAmplitude * 0.3);
                } else if (u_waveType == 4) { // Spiral waves
                    float dist = length(centeredUV);
                    float angle = atan(centeredUV.y, centeredUV.x);
                    float spiral = angle * u_flowPattern + dist * 6.28 + directionRad;
                    wave1 = sin(spiral + time * 0.8) * (0.1 + audioWaveAmplitude);
                    wave2 = sin(spiral * 2.0 + time * 1.2) * (0.05 + audioWaveAmplitude * 0.5);
                    wave3 = sin(dist * 12.56 + angle * 3.0 + time * 0.6) * (0.08 + audioWaveAmplitude * 0.3);
                } else if (u_waveType == 5) { // Spiral waves from top-left corner
                    vec2 spiralCenter = vec2(-100.0 / u_resolution.x, 1.0 + 100.0 / u_resolution.y); // Offset center
                    vec2 offsetUV = uv - spiralCenter;
                    float dist = length(offsetUV);
                    float angle = atan(offsetUV.y, offsetUV.x);
                    float spiral = angle * u_flowPattern + dist * 6.28 + directionRad;
                    wave1 = sin(spiral + time * 0.8) * (0.1 + audioWaveAmplitude);
                    wave2 = sin(spiral * 2.0 + time * 1.2) * (0.05 + audioWaveAmplitude * 0.5);
                    wave3 = sin(dist * 12.56 + angle * 3.0 + time * 0.6) * (0.08 + audioWaveAmplitude * 0.3);
                } else { // Default ripple from top-left corner (similar to type 5 but radial)
                    vec2 rippleCenter = vec2(-100.0 / u_resolution.x, 1.0 + 100.0 / u_resolution.y);
                    vec2 offsetUV = uv - rippleCenter;
                    float dist = length(offsetUV);
                    wave1 = sin(dist * 12.56 * u_flowPattern + time * 0.8) * (0.1 + audioWaveAmplitude);
                    wave2 = sin(dist * 25.12 * u_flowPattern + time * 1.2) * (0.05 + audioWaveAmplitude * 0.5);
                    float angle = atan(offsetUV.y, offsetUV.x);
                    float directionBias = sin(angle + directionRad + time * 0.3);
                    wave3 = directionBias * 0.05 + sin(dist * 18.84 + time * 0.6) * (0.08 + audioWaveAmplitude * 0.3);
                }
                
                // Noise addition for organic feel
                float noiseScale = 3.0 + u_audioOverall * u_audioSensitivity * 2.0;
                float noiseValue = fractalNoise(uv * noiseScale + time * 0.3) * (0.15 + audioWaveAmplitude);
                
                // Combine waves and noise for displacement
                float displacement = (wave1 + wave2 + wave3 + noiseValue) * (u_intensity + u_audioOverall * u_audioSensitivity * 0.5);
                float gradient = (uv.y + displacement) / u_gradientHeight; // Vertical gradient with displacement
                
                float colorPhase = gradient + audioColorShift; // Shift color based on audio
                
                vec3 finalColor;
                // Interpolate between 5 colors based on colorPhase
                if (colorPhase < 0.2) {
                    finalColor = mix(u_color1, u_color2, colorPhase * 5.0);
                } else if (colorPhase < 0.4) {
                    finalColor = mix(u_color2, u_color3, (colorPhase - 0.2) * 5.0);
                } else if (colorPhase < 0.6) {
                    finalColor = mix(u_color3, u_color4, (colorPhase - 0.4) * 5.0);
                } else if (colorPhase < 0.8) {
                    finalColor = mix(u_color4, u_color5, (colorPhase - 0.6) * 5.0);
                } else {
                    finalColor = mix(u_color5, u_color1, (colorPhase - 0.8) * 5.0);
                }
                
                // Alternative colors for mixing, reactive to audio
                vec3 altColor1 = u_color3 + vec3(u_audioBass * 0.2, 0.0, u_audioBass * 0.1);
                vec3 altColor2 = u_color1 + vec3(0.0, u_audioMid * 0.3, u_audioMid * 0.2);
                vec3 altColor3 = u_color5 + vec3(u_audioHigh * 0.2, u_audioHigh * 0.1, 0.0);
                
                vec3 altFinalColor = colorPhase < 0.5 ? 
                    mix(altColor1, altColor2, colorPhase * 2.0) :
                    mix(altColor2, altColor3, (colorPhase - 0.5) * 2.0);
                
                // Mix the main color with the alternative color based on u_colorMix
                finalColor = mix(finalColor, altFinalColor, u_colorMix);
                
                // Fade out at the edges of the screen
                float fadeY = smoothstep(0.95, 0.7, uv.y) * smoothstep(0.05, 0.3, uv.y);
                float fadeX = smoothstep(0.05, 0.1, uv.x) * smoothstep(0.95, 0.9, uv.x);
                float gradientFade = smoothstep(-0.2, 0.8, gradient);
                
                // Audio reactivity for overall brightness
                float audioBrightness = 1.0 + u_audioOverall * u_audioSensitivity * 0.4;
                finalColor *= fadeY * fadeX * gradientFade * audioBrightness;
                
                // Add subtle grain/noise
                float grainIntensity = 0.03 + u_audioHigh * u_highResponse * 0.02;
                finalColor += noise(uv * 500.0 + time) * grainIntensity;
                
                gl_FragColor = vec4(finalColor, 1.0); // Output final color
            }
        `;

        // Function to load experiments data.
        // It tries to fetch from 'experiments.json' first.
        // If fetching fails (e.g., file not found or network error), it uses inline fallback data.
        async function loadExperiments() {
            try {
                console.log('Attempting to load experiments from experiments.json...');
                const response = await fetch('./experiments.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                experiments = data.experiments;
                console.log('Successfully loaded', experiments.length, 'experiments from JSON.');
                return true;
            } catch (error) {
                console.error('Error loading experiments from JSON:', error);
                // Fallback: create experiments data inline if fetch fails
                experiments = [
                    {
                        "id": "slide-away",
                        "name": "Slide Away",
                        "colorPalette": {
                            "colors": [
                                {"hex": "#d2bd85", "rgb": [210, 189, 133]},
                                {"hex": "#d1ceb5", "rgb": [209, 206, 181]},
                                {"hex": "#1e3741", "rgb": [30, 55, 65]},
                                {"hex": "#90987c", "rgb": [144, 152, 124]},
                                {"hex": "#3a7c7f", "rgb": [58, 124, 127]}
                            ]
                        },
                        "waveDirection": {
                            "typeValue": 5,
                            "direction": 255,
                            "autoRotate": true,
                            "rotationSpeed": 1,
                            "flowPattern": 0.6
                        },
                        "visualProperties": {
                            "speed": 0.9,
                            "intensity": 0.4,
                            "colorMix": 0.5,
                            "gradientHeight": 0.5
                        },
                        "audioSettings": {
                            "sensitivity": 1.5,
                            "bassResponse": 0.9,
                            "midResponse": 0.3,
                            "highResponse": 0,
                            "isFrozen": true,
                            "frozenState": {
                                "bass": 0.5194081668441906,
                                "mid": 0.32311009685292774,
                                "high": 0.037421024639720926,
                                "overall": 0.1696532084113514
                            }
                        }
                    },
                    {
                        "id": "whatever",
                        "name": "Whatever",
                        "colorPalette": {
                            "colors": [
                                {"hex": "#2b78a8", "rgb": [43, 120, 168]},
                                {"hex": "#c2b093", "rgb": [194, 176, 147]},
                                {"hex": "#31523e", "rgb": [49, 82, 62]},
                                {"hex": "#6d8054", "rgb": [109, 128, 84]},
                                {"hex": "#66929d", "rgb": [102, 146, 157]}
                            ]
                        },
                        "waveDirection": {
                            "typeValue": 5,
                            "direction": 255,
                            "autoRotate": true,
                            "rotationSpeed": 0.2,
                            "flowPattern": 2.1
                        },
                        "visualProperties": {
                            "speed": 0.6,
                            "intensity": 0.4,
                            "colorMix": 0.85,
                            "gradientHeight": 0.75
                        },
                        "audioSettings": {
                            "sensitivity": 1.5,
                            "bassResponse": 0.8,
                            "midResponse": 0.3,
                            "highResponse": 0,
                            "isFrozen": true,
                            "frozenState": {
                                "bass": 0.5393981759261758,
                                "mid": 0.4915651997045195,
                                "high": 0.13395789636913605,
                                "overall": 0.2809263978126082
                            }
                        }
                    },
                    {
                        "id": "supersonic",
                        "name": "Supersonic",
                        "colorPalette": {
                            "colors": [
                                {"hex": "#221f2e", "rgb": [34, 31, 46]},
                                {"hex": "#303f4b", "rgb": [48, 63, 75]},
                                {"hex": "#416d7a", "rgb": [65, 109, 122]},
                                {"hex": "#d8aa6a", "rgb": [216, 170, 106]},
                                {"hex": "#846e46", "rgb": [132, 110, 70]}
                            ]
                        },
                        "waveDirection": {
                            "typeValue": 5,
                            "direction": 255,
                            "autoRotate": true,
                            "rotationSpeed": 0.6,
                            "flowPattern": 1.1
                        },
                        "visualProperties": {
                            "speed": 1,
                            "intensity": 0.3,
                            "colorMix": 0.9,
                            "gradientHeight": 0.5
                        },
                        "audioSettings": {
                            "sensitivity": 1.5,
                            "bassResponse": 0.9,
                            "midResponse": 0.3,
                            "highResponse": 0,
                            "isFrozen": true,
                            "frozenState": {
                                "bass": 0.474957183471272,
                                "mid": 0.448164226425688,
                                "high": 0.08430761680729595,
                                "overall": 0.23179357442514753
                            }
                        }
                    },
                    {
                        "id": "rock-and-roll-star",
                        "name": "Rock and Roll Star",
                        "colorPalette": {
                            "colors": [
                                {"hex": "#7e0e42", "rgb": [126, 14, 66]},
                                {"hex": "#500623", "rgb": [80, 6, 35]},
                                {"hex": "#a32861", "rgb": [163, 40, 97]},
                                {"hex": "#b86987", "rgb": [184, 105, 135]},
                                {"hex": "#d6b8be", "rgb": [214, 184, 190]}
                            ]
                        },
                        "waveDirection": {
                            "typeValue": 5,
                            "direction": 285,
                            "autoRotate": true,
                            "rotationSpeed": 0.2,
                            "flowPattern": 1.7
                        },
                        "visualProperties": {
                            "speed": 1.6,
                            "intensity": 0.9,
                            "colorMix": 0.6,
                            "gradientHeight": 0.65
                        },
                        "audioSettings": {
                            "sensitivity": 0.4,
                            "bassResponse": 0,
                            "midResponse": 1.3,
                            "highResponse": 0,
                            "isFrozen": true,
                            "frozenState": {
                                "bass": 0.4526931926647013,
                                "mid": 0.33739751313211164,
                                "high": 0.043934984681616,
                                "overall": 0.17167043081729064
                            }
                        }
                    }
                ];
                console.log('Using fallback experiments data due to fetch failure.');
                return true;
            }
        }

        // Initialize Three.js scene, camera, renderer, and shader material
        function initThreeJS() {
            try {
                console.log('Initializing Three.js...');
                scene = new THREE.Scene();
                // Orthographic camera for 2D rendering
                camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
                renderer = new THREE.WebGLRenderer({ antialias: true }); // Enable anti-aliasing for smoother edges
                renderer.setSize(window.innerWidth, window.innerHeight); // Set renderer size to full window
                document.body.appendChild(renderer.domElement); // Add canvas to the DOM
                console.log('Canvas added to DOM, size:', window.innerWidth, 'x', window.innerHeight);

                // Initialize uniforms by spreading defaultUniforms
                uniforms = { ...defaultUniforms };
                console.log('Uniforms created:', Object.keys(uniforms));

                // Create ShaderMaterial with custom vertex and fragment shaders
                material = new THREE.ShaderMaterial({
                    uniforms: uniforms,
                    vertexShader: vertexShader,
                    fragmentShader: fragmentShader
                });
                console.log('Shader material created');

                // Create a plane geometry that covers the entire screen
                const plane = new THREE.PlaneGeometry(2, 2);
                const mesh = new THREE.Mesh(plane, material);
                scene.add(mesh); // Add mesh to the scene
                console.log('Mesh added to scene');
                
                // Perform an initial render to ensure everything is set up correctly
                renderer.render(scene, camera);
                console.log('Initial render complete');
                
                // Debugging: Check canvas properties
                const canvas = renderer.domElement;
                console.log('Canvas element:', canvas);
                console.log('Canvas style:', canvas.style.cssText);
                console.log('Canvas computed style:', window.getComputedStyle(canvas));
            } catch (error) {
                console.error('Error initializing Three.js:', error);
            }
        }

        // Applies the configuration of a given experiment to the shader uniforms.
        // If 'animate' is true, it triggers a smooth transition.
        function applyExperiment(experiment, animate = false) {
            if (animate) {
                animateToExperiment(experiment);
            } else {
                // Apply colors directly
                experiment.colorPalette.colors.forEach((color, i) => {
                    if (i < 5) {
                        const rgb = color.rgb.map(c => c / 255); // Normalize RGB to 0-1
                        uniforms[`u_color${i + 1}`].value.set(...rgb);
                    }
                });

                // Apply wave direction settings
                uniforms.u_waveType.value = experiment.waveDirection.typeValue;
                uniforms.u_waveDirection.value = experiment.waveDirection.direction;
                uniforms.u_autoRotate.value = experiment.waveDirection.autoRotate ? 1.0 : 0.0;
                uniforms.u_rotationSpeed.value = experiment.waveDirection.rotationSpeed;
                uniforms.u_flowPattern.value = experiment.waveDirection.flowPattern;

                // Apply visual properties
                uniforms.u_speed.value = experiment.visualProperties.speed;
                uniforms.u_intensity.value = experiment.visualProperties.intensity;
                uniforms.u_colorMix.value = experiment.visualProperties.colorMix;
                uniforms.u_gradientHeight.value = experiment.visualProperties.gradientHeight;

                // Apply audio settings (using frozen state if available)
                uniforms.u_audioSensitivity.value = experiment.audioSettings.sensitivity;
                uniforms.u_bassResponse.value = experiment.audioSettings.bassResponse;
                uniforms.u_midResponse.value = experiment.audioSettings.midResponse;
                uniforms.u_highResponse.value = experiment.audioSettings.highResponse;
                
                if (experiment.audioSettings.isFrozen && experiment.audioSettings.frozenState) {
                    uniforms.u_audioBass.value = experiment.audioSettings.frozenState.bass;
                    uniforms.u_audioMid.value = experiment.audioSettings.frozenState.mid;
                    uniforms.u_audioHigh.value = experiment.audioSettings.frozenState.high;
                    uniforms.u_audioOverall.value = experiment.audioSettings.frozenState.overall;
                } else {
                    // If not frozen, reset audio uniforms to default or previous state
                    // For this app, we're keeping them as is if not explicitly frozen.
                    // In a real app with live audio, these would be updated by an audio analyzer.
                }
            }

            // Update navigation UI color to brightest color from the experiment
            const brightestColor = getBrightestColor(experiment.colorPalette.colors);
            updateNavigationColor(brightestColor);
        }

        // Function to find the brightest color from a color palette
        function getBrightestColor(colors) {
            let brightest = colors[0];
            let maxBrightness = 0;
            
            colors.forEach(color => {
                const [r, g, b] = color.rgb;
                // Calculate perceived brightness using luminance formula
                const brightness = (r * 0.299 + g * 0.587 + b * 0.114);
                if (brightness > maxBrightness) {
                    maxBrightness = brightness;
                    brightest = color;
                }
            });
            
            return brightest.hex;
        }

        // Updates the color of navigation elements with appropriate opacity
        function updateNavigationColor(color) {
            // Convert hex color to RGB for opacity manipulation
            const hex = color.replace('#', '');
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);
            
            // Set home icon with 50% opacity
            const homeIcon = document.querySelector('.home-icon');
            if (homeIcon) {
                homeIcon.style.color = `rgba(${r}, ${g}, ${b}, 0.5)`;
            }
            
            // Set navigation elements with 80% opacity
            const navElements = document.querySelectorAll('.nav-arrow, .nav-title');
            navElements.forEach(el => {
                el.style.color = `rgba(${r}, ${g}, ${b}, 0.8)`;
            });
        }

        /**
         * Interpolates an angle (in degrees) along the shortest path.
         * @param {number} startAngle - The starting angle in degrees.
         * @param {number} endAngle - The target angle in degrees.
         * @param {number} t - The interpolation factor (0.0 to 1.0).
         * @returns {number} The interpolated angle in degrees.
         */
        function lerpAngle(startAngle, endAngle, t) {
            let diff = endAngle - startAngle;
            // Normalize difference to be within -180 to 180 degrees
            if (diff > 180) diff -= 360;
            if (diff < -180) diff += 360;
            return startAngle + diff * t;
        }


        // Smoothly animates uniform values from current state to target experiment state
        function animateToExperiment(targetExperiment) {
            if (isTransitioning) return; // Prevent new transitions if one is already active
            isTransitioning = true;

            const duration = 2000; // Transition duration in milliseconds
            const startTime = Date.now(); // Time when the animation starts
            
            // Store current uniform values to interpolate from
            const startValues = {
                colors: [],
                waveDirection: uniforms.u_waveDirection.value,
                autoRotate: uniforms.u_autoRotate.value,
                rotationSpeed: uniforms.u_rotationSpeed.value,
                flowPattern: uniforms.u_flowPattern.value,
                intensity: uniforms.u_intensity.value, // Added intensity to startValues
                colorMix: uniforms.u_colorMix.value, // Added colorMix to startValues
                gradientHeight: uniforms.u_gradientHeight.value, // Added gradientHeight to startValues
                speed: uniforms.u_speed.value, // Added speed to startValues
                audioSensitivity: uniforms.u_audioSensitivity.value,
                bassResponse: uniforms.u_bassResponse.value,
                midResponse: uniforms.u_midResponse.value,
                highResponse: uniforms.u_highResponse.value,
                audioBass: uniforms.u_audioBass.value,
                audioMid: uniforms.u_audioMid.value,
                audioHigh: uniforms.u_audioHigh.value,
                audioOverall: uniforms.u_audioOverall.value
            };

            // Store current colors as separate R, G, B components
            for (let i = 0; i < 5; i++) {
                startValues.colors[i] = {
                    r: uniforms[`u_color${i + 1}`].value.x,
                    g: uniforms[`u_color${i + 1}`].value.y,
                    b: uniforms[`u_color${i + 1}`].value.z
                };
            }

            // Define target uniform values from the new experiment
            const targetValues = {
                colors: targetExperiment.colorPalette.colors.map(color => ({
                    r: color.rgb[0] / 255,
                    g: color.rgb[1] / 255,
                    b: color.rgb[2] / 255
                })),
                waveType: targetExperiment.waveDirection.typeValue,
                waveDirection: targetExperiment.waveDirection.direction,
                autoRotate: targetExperiment.waveDirection.autoRotate ? 1.0 : 0.0,
                rotationSpeed: targetExperiment.waveDirection.rotationSpeed,
                flowPattern: targetExperiment.waveDirection.flowPattern,
                speed: targetExperiment.visualProperties.speed,
                intensity: targetExperiment.visualProperties.intensity,
                colorMix: targetExperiment.visualProperties.colorMix,
                gradientHeight: targetExperiment.visualProperties.gradientHeight,
                audioSensitivity: targetExperiment.audioSettings.sensitivity,
                bassResponse: targetExperiment.audioSettings.bassResponse,
                midResponse: targetExperiment.audioSettings.midResponse,
                highResponse: targetExperiment.audioSettings.highResponse
            };

            // If audio settings are frozen, use their frozen state as target.
            // Otherwise, keep the current audio values (as they might be dynamic if not frozen).
            if (targetExperiment.audioSettings.isFrozen && targetExperiment.audioSettings.frozenState) {
                targetValues.audioBass = targetExperiment.audioSettings.frozenState.bass;
                targetValues.audioMid = targetExperiment.audioSettings.frozenState.mid;
                targetValues.audioHigh = targetExperiment.audioSettings.frozenState.high;
                targetValues.audioOverall = targetExperiment.audioSettings.frozenState.overall;
            } else {
                targetValues.audioBass = startValues.audioBass;
                targetValues.audioMid = startValues.audioMid;
                targetValues.audioHigh = startValues.audioHigh;
                targetValues.audioOverall = startValues.audioOverall;
            }

            // Set u_waveType immediately at the start of the transition.
            uniforms.u_waveType.value = targetValues.waveType;

            // Smooth easing function (Cubic ease-in-out)
            function easeInOutCubic(t) {
                return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
            }

            // Linear interpolation function
            function lerp(start, end, t) {
                return start * (1 - t) + end * t;
            }

            // Animation loop for uniform interpolation
            function animateUniforms() {
                const now = Date.now();
                const elapsed = now - startTime;
                let t = Math.min(1, elapsed / duration); // Normalized time (0 to 1)
                const easedT = easeInOutCubic(t); // Eased time for smooth animation

                // Interpolate colors
                for (let i = 0; i < 5; i++) {
                    uniforms[`u_color${i + 1}`].value.set(
                        lerp(startValues.colors[i].r, targetValues.colors[i].r, easedT),
                        lerp(startValues.colors[i].g, targetValues.colors[i].g, easedT),
                        lerp(startValues.colors[i].b, targetValues.colors[i].b, easedT)
                    );
                }

                // Interpolate other uniform values, using lerpAngle for waveDirection
                uniforms.u_waveDirection.value = lerpAngle(startValues.waveDirection, targetValues.waveDirection, easedT);
                uniforms.u_autoRotate.value = lerp(startValues.autoRotate, targetValues.autoRotate, easedT);
                uniforms.u_rotationSpeed.value = lerp(startValues.rotationSpeed, targetValues.rotationSpeed, easedT);
                uniforms.u_flowPattern.value = lerp(startValues.flowPattern, targetValues.flowPattern, easedT);
                uniforms.u_speed.value = lerp(startValues.speed, targetValues.speed, easedT);
                uniforms.u_intensity.value = lerp(startValues.intensity, targetValues.intensity, easedT);
                uniforms.u_colorMix.value = lerp(startValues.colorMix, targetValues.colorMix, easedT);
                uniforms.u_gradientHeight.value = lerp(startValues.gradientHeight, targetValues.gradientHeight, easedT);
                uniforms.u_audioSensitivity.value = lerp(startValues.audioSensitivity, targetValues.audioSensitivity, easedT);
                uniforms.u_bassResponse.value = lerp(startValues.bassResponse, targetValues.bassResponse, easedT);
                uniforms.u_midResponse.value = lerp(startValues.midResponse, targetValues.midResponse, easedT);
                uniforms.u_highResponse.value = lerp(startValues.highResponse, targetValues.highResponse, easedT);
                uniforms.u_audioBass.value = lerp(startValues.audioBass, targetValues.audioBass, easedT);
                uniforms.u_audioMid.value = lerp(startValues.audioMid, targetValues.audioMid, easedT);
                uniforms.u_audioHigh.value = lerp(startValues.audioHigh, targetValues.audioHigh, easedT);
                uniforms.u_audioOverall.value = lerp(startValues.audioOverall, targetValues.audioOverall, easedT);

                if (t < 1) {
                    requestAnimationFrame(animateUniforms); // Continue animation
                } else {
                    isTransitioning = false; // Transition complete
                    console.log('Transition complete to experiment:', targetExperiment.name);
                }
            }
            requestAnimationFrame(animateUniforms); // Start the animation
            
            // Update navigation color during transition to brightest color
            const brightestColor = getBrightestColor(targetExperiment.colorPalette.colors);
            updateNavigationColor(brightestColor);

            // Animate navigation title fade
            const navTitle = document.getElementById('navTitle');
            navTitle.classList.add('fading');
            setTimeout(() => {
                navTitle.textContent = targetExperiment.name;
                navTitle.classList.remove('fading');
            }, duration / 2); // Change text halfway through the fade
        }

        // Main animation loop for the shader
        function animate() {
            animationId = requestAnimationFrame(animate); // Request next frame
            uniforms.u_time.value += 0.01; // Increment time uniform

            // Normalize u_waveDirection to keep it within 0-360 degrees
            // This prevents it from growing indefinitely, ensuring consistent angular interpolation.
            uniforms.u_waveDirection.value = (uniforms.u_waveDirection.value % 360 + 360) % 360;

            renderer.render(scene, camera); // Render the scene
        }

        // Handles window resizing to update renderer and uniform resolution
        function onWindowResize() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            renderer.setSize(width, height);
            uniforms.u_resolution.value.set(width, height);
            console.log('Window resized:', width, 'x', height);
        }

        // Function to create pagination dots
        function createPaginationDots() {
            const dotsContainer = document.getElementById('paginationDots');
            dotsContainer.innerHTML = ''; // Clear existing dots
            
            experiments.forEach((_, index) => {
                const dot = document.createElement('div');
                dot.className = 'pagination-dot';
                if (index === currentExperimentIndex) {
                    dot.classList.add('active');
                }
                dot.addEventListener('click', () => navigateToExperiment(index));
                dotsContainer.appendChild(dot);
            });
        }

        // Function to update active pagination dot
        function updatePaginationDots() {
            const dots = document.querySelectorAll('.pagination-dot');
            dots.forEach((dot, index) => {
                if (index === currentExperimentIndex) {
                    dot.classList.add('active');
                } else {
                    dot.classList.remove('active');
                }
            });
        }

        // Function to navigate to a specific experiment by index
        function navigateToExperiment(index) {
            if (isTransitioning || index === currentExperimentIndex) return;
            currentExperimentIndex = index;
            applyExperiment(experiments[currentExperimentIndex], true);
            updatePaginationDots();
        }

        // Function to navigate to the next experiment
        function showNextExperiment() {
            if (isTransitioning) return;
            currentExperimentIndex = (currentExperimentIndex + 1) % experiments.length;
            applyExperiment(experiments[currentExperimentIndex], true); // Animate to next
            updatePaginationDots();
        }

        // Function to navigate to the previous experiment
        function showPreviousExperiment() {
            if (isTransitioning) return;
            currentExperimentIndex = (currentExperimentIndex - 1 + experiments.length) % experiments.length;
            applyExperiment(experiments[currentExperimentIndex], true); // Animate to previous
            updatePaginationDots();
        }

        // Event listeners for navigation buttons
        document.getElementById('nextBtn').addEventListener('click', showNextExperiment);
        document.getElementById('prevBtn').addEventListener('click', showPreviousExperiment);

        // Touch event listeners for swipe navigation
        document.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
        });

        document.addEventListener('touchend', (e) => {
            touchEndX = e.changedTouches[0].clientX;
            handleSwipeGesture();
        });

        function handleSwipeGesture() {
            const swipeDistance = touchEndX - touchStartX;
            if (swipeDistance > minSwipeDistance) {
                // Swipe right (previous)
                showPreviousExperiment();
            } else if (swipeDistance < -minSwipeDistance) {
                // Swipe left (next)
                showNextExperiment();
            }
        }

        // Initialize the application when the window loads
        window.onload = async function() {
            console.log('Window loaded.');
            await loadExperiments(); // Load experiment data
            initThreeJS(); // Initialize Three.js
            
            // Apply the first experiment's settings immediately
            if (experiments.length > 0) {
                applyExperiment(experiments[currentExperimentIndex], false); // No animation on initial load
                document.getElementById('navTitle').textContent = experiments[currentExperimentIndex].name;
                createPaginationDots(); // Create pagination dots
            } else {
                console.error("No experiments loaded. Cannot initialize shader.");
                // Potentially display an error message to the user here
            }

            animate(); // Start the Three.js animation loop
            window.addEventListener('resize', onWindowResize); // Add resize listener
            console.log('Application initialized and animation started.');
        };
    </script>
</body>
</html>
